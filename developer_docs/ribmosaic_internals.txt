Welcome to the RIB Mosaic developer documentation! This document outlines the
systems design as well as the modules and classes around which RIB Mosaic is built.


SYSTEM DESIGN:

General Design:
RIB Mosaic is a RenderMan IDE providing an architecture for technitians to package
and distribute tools for artists. RIB Mosaic by itself only provides the core RIB
exporting capabilities but includes a interface for technitians to build GUI panels
that execute Python scripts, insert RIB, RSL and command line code directly into
the export stream. This is achieved through writing Python, RIB, RSL and command
line code in XML documents called RIB Mosaic pipelines. These pipelines make it
possible to add, remove and distribute tightly integrated RenderMan functionality
in a very modular fashion while extending the funtionality of RIB Mosaic.
RIB Mosaic removes all Blender property panels that do not directly relate to
RenderMan or the exporter and adds a few additional panels for exporter control
and pipeline management. It also modifies the text editor by adding a property panel
and right click menu options to turn the text editor into an XML pipeline editor.
By removing all Blender panels related to the internal renderer and shading system
RIB Mosaic pipelines have free reign to add panels specifically for RenderMan
shading, rendering and RIB manipulation (or anything else the TD wants).
RIB Mosaic organizes its interface around Blender's properties windows according
to RenderMan RIB structure. From left to right in Blender's property windows:
- Render = Utility panels related to rending and frame RIB (such as display RIB)
- Scene = Lowest data level representing global export options and command panels
- World = Represents world block and global shaders (such as atmosphere)
- Object = Represents object RIB archives (including parent/children relationships)
- ObjData = RenderMan primitives RIB code
- Material = Shader RIB code shared by objects and objdata
- Textures = Command panels for texture optimization (pre render pass)
- Particles = Particle system RIB code
When panels are created they can be assigned to which window or windows they will
show in. Panels can be searched in the Pipeline Manager's search menu's and once
selected panels can be registered to Blender and pinnned/unpinned to the datablock.
Registration makes it possible for a pipeline to have thousands of panels
available without being loaded in Blender. It is best to keep all panels registered
for small feature specific pipelines and all unregistered in large shader pipelines.
Once a panel is registered it can then be pinned or unpinned to each datablock.
If properly designed panels can also be duplicated and deleted easily by the artist
for various purposes. Now lets look at the four interconnected systems that RIB
Mosaic is built around:
- XML Pipelines
- Data Links
- Export Context
- Render Passes
The following outlines each.

Pipeline Design:
As mentioned above what makes the entire system both flexible and portable are
pipelines. Pipelines are just XML documents that are loaded in Blender's text
editor and parsed with ElementTree by RIB Mosaic's pipeline_manager class.
Pipelines serve a couple important purposes:
- Packages RIB, shader and script code related to specific features or tasks
- Stores path to a shader library to be maintained by the pipeline
The first point means that pipelines should be targeted for very specific
purposes making it possible to add and remove many pipelines without conflict.
The second point hints that pipelines are involved in maintaining shaders.
Shader sources can be used in three different places by RIB Mosaic:
- Loaded and compiled directly in Blender's text editor
- Embedded directly in pipelines XML (for specific purposes in pipeline)
- Stored in a directory and the shader libraries path stored in the pipeline
Shader libraries are simply a path to shader sources stored in the pipelines.
This allows a pipeline to maintain all shaders in the library. This also allows
the pipeline to be easily distributed with a shader library if using relative paths.
Shader sources are exported to separate folders according to where they came from
with the RIB calls prefixed using the path. This allows shaders from many different
pipelines or sources to have the same name in the same project.
RIB Mosaic processes shaders in several steps:
- Shaders are compiled by the commands in a command panel of type COMPILE
- Shader info is extracted and converted to slmeta files by a INFO command panel
- Slmeta files are then used to generate shader panel elements in a pipeline
There are several reasons these steps are necessary:
- Shaders are not always used from source but pre-compiled therefore cannot
  always be interpretted directly from rsl source
- slmeta files can be generated by several external utilities so its possible
  to modify a shader interface without compiling shader source (shrimp, k3d)
  also these utilities allow shader and parameter comments
- shader panels are XML structures in pipelines so they can can contain tooltips
  and shader comments from slmeta data generated from external editors, also
  this technique allows for multiple shaders of the same type to be enabled on
  the same datablock (for features like layered shading) and finally shader
  parameters can be linked to other Blender controls by storing them in XML.
This last point is important because it allows a pipeline developer to link a
Blender control to a specific shader parameter and distribute it with the pipeline.
For instance they may want the spotlight.sl coneangle to be controlled by Blender's
lamp Spot size. Currently any shader panel generated by RIB Mosaic includes small
buttons next to each parameter to allow the user to paste the data path of another
control to that parameter. The control will gray out and will be linked to the
parameter the path points to. One restriction is the path must point to a control
on the same datablock.
Pipelines can be loaded in two ways:
- Use the load button in any of the Pipeline Manager panels throughout the GUI
- Place pipeline rmp files in the add-on's pipeline folder
This second technique will cause RIB Mosaic to automatically load and use those
pipelines when the add-on is enabled. These pipelines are copied to the blend's
text editor and can be locally modified without affecting the external files.
These types of pipelines cannot be removed by the user forcing certain functionality.
This mechanism is primarily meant as a means for distributing complete add-on
packages for renderer developers (see CUSTOMIZATION in the root README.txt).
Once a pipeline is loaded it can be modified by selecting it in Blender's text
editor. The editor also has a pipeline manager panel added to the properties
window that has XML code selection based on element lists and typed XML paths.
Also the right click menu has been modified to add helpful tools such as escaping
or unescaping XML code, copying XML paths, showing comments on attributes and
elements (very important for learning what things do) and inserting standard
elements.
XML pipeline documents contain a root element defining pipeline attributes and
then the following sub elements:
- python_scripts = Container for elements whose text defines Python code to be
                   executed by EXEC links
- shader_sources = Container for elements whose text defines RSL shader source
                   embedded in the pipeline
- shader_panels =  Container for elements defining shader panels added to
                   Blender's UI that inject shader RIB into the export stream
- utility_panels = Container for elements defining utility panels added to
                   Blender's UI that inject user RIB into the export stream
- command_panels = Container for elements defining command panels added to
                   Blender's UI that inject CL code onto the command line
As hinted at above pipelines both define the panels shown in Blender's UI
(including the properties the panel controls require) as well as the user defined
code to be injected into the export stream the panel is to represent. Therefore
the panel type determines what type of user code it is to contain as well as
where that code will be exported such as...
- shader panels =  passes shader parameters from the panel to RIB code to call
                   on a shader from a Blender datablock.
- utility panels = contains user defined RIB code to be inserted in the RIB
                   stream relative to the datablock the panel is enabled on.
                   Panel buttons can also trigger embedded Python scripts to
                   peform duties such as creating rigs, or adding/removing passes.
- command panels = contains command line code to be exported as shell/batch
                   scripts. All command execution happens through command panels
                   including calling the shader compiler and renderer.
All panels include three common sub elements:
- regexes
- properties
- layout
The "regexes" sub elements allow you to define regular expressions that can
perform string replacement filtering on the underlying exported file.
If a regex is applied to a shader or utility panel then you are filtering the
RIB archive for the datablock the panel is on. If a regex is applied to a
command panel then you are filtering the exported shell/batch script.
This mechanism allows a pipeline developer to directly modify the standard RIB
output of RIB Mosaic for their own needs without having to directly modify the
add-on. One example of using this is how the info command panel uses regex to
filter the redirected output of shader info into an slmeta XML file.
The "properties" sub element contains the properties to be used by panel controls.
In Blender all controls in the GUI are actually datablock properties, RIB Mosaic
separates properties from layout controls so its possible to create a property
without using it in the GUI (for storing values in a panel). The attributes for
the property sub element directly mimics Blender's property API.
The "layout" sub element defines a nested sub element tree defining the layouts
and controls that makeup the panels GUI. Each sub element can be two categories:
- layout elements
- control elements
Layout elements define groups of controls such as rows, columns or splits.
Control elements define controls using property elements. This all closely follows
Blender's UILayout class in the API. One important feature unique to RIB Mosaic
is the "type" attribute for controls. A control widget can have the following
types:
- SEP = Layout separator
- LABEL = Text label, the "text" attribute is used for the label
- PROP = Show property control, "prop" is the property element name
- PROPSEARCH = Same as PROP but "trigger" should be a full data path to collection
- BUTTON = Shown as a button and reads the "trigger" attribute when the button
           is pressed (use an EXEC link to trigger a script). If the script
           passes a string through its "ouput" global then its shown in a popup.
- LINK = Activates the link popup, the "trigger" attribute should point to the
         xmlpath to a property to force a link in (links to another property)
- INFO = Activates an info popup, the "trigger" attribute should contain the
         message to display in the popup
- FILE = Activates the file dialog, the "trigger" attribute should contain the
         property name (Blender datapath) of the string to pass the path too.
         Use the @[PROP::]@ link to get the hash name of a panel property.
Within XML "data links" can be used in any element text or attribute to pass
information between panel properities and RIB see the next section for details.

Link Design:
RIB Mosaic links are special strings that instruct the exporter to grab data from
one place and return it inline as a formatted string. Links are the most important
system in RIB Mosaic as they allow information to be passed from anywhere in Blender.
Links can be used in the following places:
- Any pipeline XML attribute
- Any pipeline XML text
- Any text control in Blender's UI that's referenced by RIB Mosaic
The data link format is @[token:xmlpath(paras):option*depth]@ where "token"
determines the link type, "xmlpath" points to the data, "paras" are named
parameters, "option" filters the returned string and "depth" sets the max recursion
depth. Named parameters only work for EXEC tokens and can themselves contain
links. Links can also be nested in one another and are evaluated inside out.
Here's details of link format...
Token Types:
EVAL = Python expressions or "." + export context variable (uses parameters)
EXEC = XML path to script or "." + export context method (uses parameters)
STXT = Text editor shaders export path in OS or RIB format depending on options
SXML = XML shaders export path in OS or RIB format depending on options
SLIB = Library shaders path in OS or RIB format depending on options
TEXT = Text element link (returns elements text)
ATTR = Attribute element link (returns elements attribute)
PATH = Return full XML path from relative path (handy for scripts)
DATA = Return property data from either xmlpath or "." + Blender datapath
PROP = Return property name generated by RIB Mosaic from xmlpath
XMLPath Syntax:
XML absolute = root_element/sub_element/sub_element
XML relative = //sub_element
For ATTR = root_element/sub_element/.../sub_element.attribute
For EVAL = any valid Python expression
Options:
#### = Returns numbers with leading zeros up to number of # characters
RIB = Returns in RIB format (for paths returns nix relative export path)
RSL = Returns in RSL format
PY = Returns in Python format
STR = Returns as a quoted string
unspecified = Data is converted to string without quotes
*# = Set the recursion limit for current link (for links calling links)
Generally relative XML paths should always be used unless you need to access
data from another pipeline. Using relative paths make it possible for the user
to duplicate your panel without breaking it's internal link paths.
Here's a few link examples:
Return quoted string of a Python expession = @[EVAL:1+1:STR]@
Example of nesting = @[EVAL:1+@[EVAL:1+1:PY]@:STR]@
Return current RIB archive from context = @[EVAL:.archive_name:STR]@
Run a script in current pipeline @[EXEC:/python_scripts/myscript(mypara=0):]@
Execute an export context method @[EXEC:.pass_add(name="mypass"):RIB]@
Return the text from an element = @[TEXT:mypipeline:STR]@
Return an element attribute = @[ATTR:mypipeline.filepath:STR]@
Return data from a panel property = @[DATA:///properties/mybut:]@
Return data from a datablock path = @[DATA:.myprop:]@
As mentioned above links can also be used throughout Blender's UI in any text
control that RIB Mosaic reads for export. This makes it possible to create
dynamic strings where static would usually only be possible. One good example
is in the "Scene->Export Options->Export Path:" panel property which uses
links to make an export path using the name and location of the blend. Links
can also do interesting things in XML such as enabling or disabling a layout
group according to the value of another control (such as showing or hiding a
group of controls based on a toggle control).

Context Design:
Export context has been mentioned several times above but not explained. Nearly
every class in RIB Mosaic is inherited from the ExportContext class. This class
is used by the following objects in RIB Mosaic:
- UI panels
- operators
- pipeline links
- file archives
The context class contains public variables that are automatically maintained
during the creation and destruction of these objects. If an object is instanced
by another object, such as a parent object archive creating a child object
archive or a link that calls another link recusively, then these variables are
inherited. The variables maintain the state of the object relative to where it
belongs in the pipeline and export system. Since all XML text can be accessed
by any of the above objects they can be related back to the pipeline, since any
text can contain a link then it can access information in the context for the
objects that contains it. For instance the RIB code in a panel can have a link
that inserts the value of a panel control, when the RIB is exported the link
resolves the controls value. Another example would be a BUTTON panel control
that executes a script with the "trigger" attribute that in turn uses a link to
read the current objects context variable "current_pipeline". Since the link is
executed in a panel then the panel's context would be inialized to the pipeline
that contains it. In general panels, operators and links only contain acurate
context about where they are in a pipeline however a archive object will contain
more export related information. For this reason links contained in RIB code
can access anything they need about the export context including using the
"pointer_parent" variable to drill down the export hiearchy, while links triggered
in a panel or UI should only try to use pipeline path information.
The export class also has public methods that provide services specifically for
links to be used in RIB or utilty scripts. For instance the following placed
in the "trigger" attribute of a BUTTON control would create a new render pass
@[EXEC:.add_pass(name=@[DATA:///properties/mybut:STR]@):]@ using the value in
the panels "mybut" control.

Pass Design:
Render passes in the new RIB Mosaic are not scenes but a collection of data on the
scene datablock. They can be found in the Render property window under RenderMan
passes (to distiguish them from Blender's passes). Passes function in much the
same way as in the previous RIB Mosaic as they define the active camera and how
the scene for each pass is setup. Passes can be created, duplicated, sorted and
grouped. There are also helper operators for creating sequence passes and tile
render passes. The following are some of the more important controls in passes.
The "Output" control allows the user to specify the name of the output image.
This value is stored in the export context's "pass_output" variable and is
accessible to render panels RIB code. This makes it possible for RIB Mosaic to
know the name of the rendered image to load in Blender's render result but also
makes it possible for this name to be put in panel's display RIB code using a
token such as @[EVAL:.pass_output:]@. The toggle next to the output control
enables multilayered EXR output. When enabled the rendered image will be loaded
in Blender's render result as a layered EXR however you'll need to be sure to use
layered EXR display code when rendering the image. The Aqsis_Core test pipeline
comes with one that will need to be enabled to use (be sure to also disable the
file display). The render layer control (near the bottom) specifies which render
layer the image uses in Blender. If unspecified then is assigned to all layers.
When dealing with layered EXR's its important to be sure the outputs of your
display RIB match the passes for the Blender layer.
One last important control to mention in passes is the "Panel Filter" control.
This control can take any Python expression and/or links to evaluate to True or
False, 0 or 1 and enables or disables all panels relative to the current pass.
For example if you enter "False" in this control all panels for this pass are
disabled. This not only disables the panels UI visibility but export as well.
This filter can be combined with the "filter" attributes in each panel's XML
to disable panels based on certain criteria. For example to disable all panels
but surface shaders you could use the following inline Python expression:
True if "SURFACE" in @[ATTR://.filter:STR]@ else False
It's also important to note that this not only disables panels that are enabled
but can also enable panels that where disabled (unless not registered). This
mechanism is not really meant for the artists but is intended as a way for a
script to create a pass that enables/disbles certain content in the scene or
its own pipeline (such as disabling all shaders but the one for this pass, ect).
For instance you could create a panel that contains a BUTTON that triggers an
EXEC that creates a pass and inserts a filter expression that disables all
shaders but one that contains the "POINTBAKE" filter (for baking a point cloud).

With pipeline XML, links and context variables and methods nearly any Renderman
concept can be tightly intergrated and packed in a way that artists can simply
load and use without knowledge of RenderMan code.


SOURCE MODULES:

The following is an outline of the RIB Mosaic source modules:

__init__.py
The initialization module is the first started by Blender when add-on is enabled.
This module has several responsibilities:
- Initializes the bl_info dictionary for Blender add-on's.
- Initializes global variables and defines global functions used throughout
  all other modules. It's also important to note this is the only module
  defining globals as all other modules contain class definitions only.
- Imports or reloads RIB Mosaic modules for Blender add-on.
- Defines the Blender add-on register and unregister functions.
- Creates and destroy's the add-on's properties.
- Initializes the global RIB Mosaic class objects (pipeline_manager,
  export_manager, ribify).

rm_property.py
This module contains class and property definitions for all RIB Mosaic's properties
and pointers, as well as funtions used to create and destroy them during __init__.

rm_error.py
This module defines the RibmosaicError class used for handling internal
errors. Errors can display a text message and traceback info to both the console
and/or a popup (depending on context).

rm_panel.py
This modules contains all classes for permanent UI panels (not pipeline panels),
and menus. It also contains the RIB Mosaic RenderEngine class Blender uses for
rendering and the super class for GUI polling and panel enabling. Its important
to note that the actual exporting in Blender only happens in the RenderEngine
class, all other code is either GUI or support code. Therefore see RibmosaicRender
to follow the export process (that in turn calls the classes in rm_export.py)

rm_operator.py
This module contains all operator classes. Operators are used in Blender to
perform any GUI related operation. Therefore this module contains operators
for all menus and panels. It also contains a super class called RibmosaicOperator
that provides common useful methods for all operators in RIB Mosaic.

rm_pipeline.py
This module contains the PipelineManager class responisble for all pipeline
related duties. Specifically this class is initiated in __init__.py as the global
object "pipeline_manager" and is used to:
- Load/Remove/Save .rmp files in Blender's text editor
- Parse pipeline XML and pass them into ElementTree (for element data access)
- Generating Blender GUI panel Python classes and properties from element data
- Registering and unregistring panel classes to Blender's GUI
- Loading and parsing slmeta XML files and generating shader panel elements
- Providing an interface to abstractly search pipeline element and attribute data
- Providing an interface to abstractly get/set pipeline element and attribute data
- Transparently resolves links in any element text or attribute on retrieval
- Contains a dictionary providing the structure for all pipeline element and
  attributes and sub-elements (as well as comments on them for the GUI editor)

rm_link.py
This module contains the PipelineLink class responsible for defining the link
object. Link objects are created for each link found in a string and contain
methods necessary to parse the string, find the data pointed to by the link
path and replace the link with a string of the data. Link objects also
creates child link objects for "links within links", automatically inheriting
context variables from the parent link. This makes it possible to place any
number of links within other links or for a link to directly call another (even
drilling down a link chain). This chain of link processing is handled automatically
however it is also possible to process any link in the chain manually.
The ExportContext class is primarily responsible for starting the link resolution
process so calling the methods within this class directly are usually not necessary.

rm_context.py
This module contains the ExportContext super class that nearly all other classes
are subclassed from. This classes private methods provide basic utilities for
getting or setting the export context of any object derived from this class.
The export context is information about an initialized object relative to its
place within a RIB Mosaic Pipeline, RIB Mosaic Link or RIB Mosaic Archive. This
information is populated in this classes variables during object initialization
and can be inherited by subsequent child objects. This information makes it
possible to pass data from a pipeline GUI panel through a link to archive RIB
since all objects share the same super class. This classes public methods are
intended to be visible to Blender's GUI in the text editor to be used in EXEC
links for simple text manipulation (such as returning a RIB comment based on the
state of a panel property, ect). This classes private methods are used by the
various sub class types that inherit it. Two of the most important ones are:
- _resolve_links() = Resolves any links found in passed string
- _panel_enabled = Returns whether a specified panel is enabled or not

rm_export.py
This module contains the ExportManager class responsible for all exporting
related duties. Specifically this class is initiated in __init__.py as the global
object "export_manager" and is used to:
- Resolve the export path provided by the user
- Generate and maintain the export directory and sub directories
- Find and export all shader sources contained in Blender's text editor and pipelines
- Find and export all Blender textures as images using their OPTIMIZE command panels
- Collect all render passes and setup the export list structure
- Process the export list and begin creating archive objects for RIB and commands
- Collect all command archives created to be executed on the CL after export
This module also contains several other classes for creating various archive objects.
An archive object creates and maintains a file pointer for either a RIB archive
or command shell/batch script. Archive objects automatically generate and maintain
the underlying file pointer and all write operations performed through the class.
The ExporterArchive is the super class providing all generic archive creation
and management code including:
- Creating and maintaining the file pointer (including gzipped and executables)
- Writing text to file both appended or inserted (searches and inserts to markers)
- Maintaining an export cache on archive (to determine when to export or reuse)
- Coordinating with threading manager for each object
- Automatically closing and cleaning up file object
- regex string replacement filtering on closed files
Then several sub classes of ExporterArchive create export objects representing
the three standard types of RIB Mosaic panels:
- Shader Panel = ExporterShader
- Utility Panel = ExporterUtility
- Command Panel = ExporterCommand
Each of these sub classes hold an xmlpath to the panel they represent and can
either create a new archive or use an existing archive since they are derived
from ExporterArchive. They also provide methods for extracting, link resolving
and writing code from the panel's XML to the archive object. The remainder of
the classes in this module are classes for creating the underlying RIB archives
for export. Each class represents a Blender datablock and RIB archive according
the directory and file structure RIB Mosaic exports:
- ./Archives/Pass+Frame RIB = ExportPass
- ./Archives/Worlds/World Shader RIB = ExportWorld
- ./Archives/Lights/Light Shader RIB = ExportLight
- ./Archives/Objects/Object RIB = ExportObject
- ./Archives/Objects/Geometry/Geometry RIB = ExportObjData, ExportParticles
- ./Archives/Objects/Materials/Material RIB = ExportMaterial
Each of these classes represent a complete RIB archive and each can create
new objects inherited from themselves. For instance ExportPass is created which
in turn finds all parent objects in the pass/scene and creates an ExportObject
for each. Then each ExportObject creates child ExportObjects for each child object
in the parent (inheriting the attributes of the parent), and so on. This mechanism
provides many advantages:
- The exporter can follow parent child relationships in Blenders objects
- Those parent child arhive links can be used for things like CSG
- With each object being an ExportContext any links can navigate the heiarchy
- Opens the possibility of using theading during object export
One other very important thing to note about this structure is the archives
and export objects direcly line up with Blender's datablock stucture:
- scene
- world
- lamp
- object
- objdata
- particles
- materials
This means the datablocks and attached RIB Mosaic panels can be directly exported
to an RIB archive (something the previous exporter did not do). To wrap all this
up the export process begins with RibmosaicRender in rm_panel.py and is called by
Blender automatically. Next RibmosaicRender uses the export_manager global to
call the following methods in this order:
- export_manager.prepare_export
- export_manager.export_shaders
- export_manager.export_textures
- export_manager.export_rib
- export_manager.execute_commands
Then the export_rib method collects information for the specified pass and scene,
creates and collects all comand objects (to be executed after export), and creates
an ExportPass object.
ExportPass then creates an ExportWorld object and collects all parent objects
in scene creating ExportObject and ExportLight objects.
Each ExportObject then collects child objects creating new ExportObject objects
for each of them. Then ExportObject collects and creates ExportMaterial objects,
ExportObjData and ExportParticles (both of which use the rm_ribify.py module).
This process is managed by a cache file system that keeps track of which archives
have already been exported and/or reused and which datablocks in Blender require
re-export from frame to frame. Each of these objects can return text that's
written to the parent object. For instance if a object archive calls a child
archive, and the child is using the ReadArchive type, then the child will return
the RiReadArchive RIB to be inserted in the parent. If using an inline type
the child object is passed the pointer to the parent and all write operations
happen directly to the parent file pointer.

rm_ribify.py
This module contains the Ribify class responsible for all geometry exporting
related duties. Specifically this class is initiated in __init__.py as the global
object "ribify". This global object has a special initialization process. When
RIB Mosaic initializes __init__.py it trys to import the "ribify" C Python module,
if found RIB Mosaic will use a fast C level module for geometry exporting. If
not found RIB Mosaic will use the internal rm_ribify.py script module. These two
modules actually use the same code found in rm_ribify.py however the low level
module uses the rm_ribify.pxd file and Cython to compile the Python script into
a C Python Module. If your production requires a faster lower level exporter
follow the instructions in BUILD.txt to build and install this module.
In order for ribify to work both as a script and a C module it is intentionally
designed to avoid accessing any structures or code in RIB Mosaic and tries to
only access data directly in Blender and archive file pointer. For this reason
Ribify has its own file write_text() that writes to a Python file pointer passed
to an attribute variable. The geometry export works in two parts:
- Export geometry found in passed Blender datablock to specified RenderMan primitive
- Append specified datablock data to a RenderMan primitive variable (primvar)
In RenderMan the RIB used to define a RenderMan primitive is contained in the
top half of the RIB code making it easy to add user defined variables to the
primitive after (such as UV coordinates, color, alpha or user defined).
RIB Mosaic completely separates these two so the user can specify which standard
primitive types to add (such as vertex color, uv, ect) from the GUI, but also
let utility panels use links to call on ribify directly and specify any data
within a Blender datablock to be appended as any RenderMan primitive type.
The geometry export methods also need to be able to export nearly any Blender
datablock type into any compatible RenderMan primitive type, for instance it
should be possible to pass a mesh datablock to ribify but export the mesh as a
mesh, points, curves, ect.

